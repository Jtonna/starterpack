<lifecycle name="ENTRY">

  <overview>
    Defines how work enters the system, how the orchestrator routes it to the correct
    lifecycle strategy, and how scope is enforced during execution. Every change to the
    codebase must be tied to a beads ticket — no exceptions.
  </overview>

  <entry-points>
    <!--
      Work can arrive in three forms. The orchestrator must identify which type it is
      and route accordingly. If the request does not clearly match one of these, ask
      the human to clarify before proceeding.
    -->

    <entry name="EXISTING_TICKET">
      <description>A beads ticket already exists (the human says "work on KAN-29b" or the orchestrator picks one from "bd ready").</description>
      <action>Run "bd show ID" to read the ticket, then proceed to PLANNING lifecycle.</action>
      <status-message>executing ENTRY/EXISTING_TICKET — loading {ticket-id}</status-message>
    </entry>

    <entry name="SPEC_FILE">
      <description>
        The human points to a spec file (e.g. SPEC.md) or provides a large feature description
        that needs to be broken into multiple tickets before work can begin.
      </description>
      <actions>
        <action>Read the spec file</action>
        <action>Create an epic ticket summarizing the full scope: bd create --type epic --title "..." --description "..."</action>
        <action>
          Decompose the spec into individual feature/task tickets. For each:
          - bd create --type feature|task --title "..." --description "..."
          Do NOT create dependencies between children and the epic — the epic is a tracking
          container, not a blocker. The orchestrator tracks which tickets belong to the epic.
        </action>
        <action>
          Establish dependencies between child tickets where ordering matters:
          - bd dep add {later-ticket} {earlier-ticket}
          Only add deps between children that have real sequential dependencies.
        </action>
        <action>Present the full ticket breakdown to the human for approval before starting any work</action>
        <gate>BLOCKED — Do not proceed. Human approval of the ticket breakdown is required before starting any child ticket work.</gate>
        <action>Once approved, beads changes will be committed on the current branch automatically (the pre-commit hook stages .beads/issues.jsonl). The GitHub Action syncs issues from any branch.</action>
        <action>Pick the first ready ticket (bd ready) and proceed to PLANNING lifecycle</action>
      </actions>
      <status-message>executing ENTRY/SPEC_FILE — decomposing spec into tickets</status-message>
    </entry>

    <entry name="AD_HOC_REQUEST">
      <description>
        The human gives an instruction directly (e.g. "add a logout button", "fix the header alignment").
        This is NOT a ticket yet.
      </description>
      <actions>
        <action>
          Before doing any work, create a beads ticket:
          - bd create --type feature|bug|task --title "..." --description "..."
          - Use the human's request as the description basis
        </action>
        <action>Confirm the ticket with the human: "Created {ticket-id}: {title}. Proceeding with this."</action>
        <action>Beads changes are committed on the current branch automatically. The GitHub Action syncs issues from any branch.</action>
        <action>Proceed to PLANNING lifecycle with the new ticket</action>
      </actions>
      <rule>
        Never implement an ad-hoc request without a ticket. The ticket is the audit trail.
        If the human insists on skipping the ticket, explain that every change must be tracked
        for traceability and push back respectfully.
      </rule>
      <status-message>executing ENTRY/AD_HOC_REQUEST — creating ticket for request</status-message>
    </entry>
  </entry-points>

  <branching-strategy>
    <!--
      Strategy definitions are in .starterpack/behaviors/git-workflow.xml. The selection logic
      below determines which strategy to use.
    -->

    <requires-behavior name="git-workflow" />

    <selection>
      The orchestrator determines the strategy during entry point routing:
      - SPEC_FILE entry → FEATURE_BRANCHING (always)
      - EXISTING_TICKET with type "epic" → FEATURE_BRANCHING
      - EXISTING_TICKET with any other type → TRUNK_BASED
      - AD_HOC_REQUEST → TRUNK_BASED (unless the orchestrator determines during PLANNING/INTAKE that it should be an epic)
    </selection>
  </branching-strategy>

  <requires-behavior name="scope-enforcement" />

</lifecycle>
