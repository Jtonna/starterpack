<lifecycle name="IMPLEMENTATION">

  <overview>
    Executed after a plan is approved in the Planning workflow. The orchestrator acts as Agent Team
    lead, directly spawning implementation teammates and coordinating their work. Sub-agents cannot
    spawn other sub-agents, so the orchestrator manages the team directly.
  </overview>

  <loop>
    <!--
      LAUNCH → DISPATCH → MONITOR → EVALUATE → HUMAN_GATE → HANDOFF
                  ▲           │
                  │  failure   │
                  └─ ESCALATE ─┘
                       │
                       │ stuck → human
    -->

    <phase name="LAUNCH" order="1">
      <actor>Orchestrator (acting as Agent Team lead)</actor>

      <actions>
        <action>Read the approved plan, ticket ID, ticket issue_type, and branching strategy</action>
        <action>
          Branch handling depends on the branching strategy (set during ENTRY workflow):

          TRUNK_BASED: The orchestrator creates a new branch before dispatching any teammates.
          Branch naming: look up the ticket's issue_type in .starterpack/config/beads.xml issue-types
          to find the corresponding branch-prefix.
          Example: issue_type "feature" → branch-prefix "FEAT/" → git checkout -b FEAT/sp-0004

          FEATURE_BRANCHING: The orchestrator checks if the epic branch (EPIC/epic-id) exists.
          If it does not exist (first child ticket), create it: git checkout -b EPIC/epic-id
          If it already exists (subsequent child tickets), check it out: git checkout EPIC/epic-id
          All child ticket commits go to the same epic branch.
        </action>
        <action>Create the Agent Team for this implementation cycle</action>
      </actions>

      <status-message>executing IMPLEMENTATION/LAUNCH on {ticket-id} with team lead</status-message>
    </phase>

    <phase name="DISPATCH" order="2">
      <actor>Orchestrator (Team Lead)</actor>

      <actions>
        <action>Read the plan's sub-task list and dependency ordering</action>
        <action>
          For each sub-task, determine the model tier using the planner's complexity rating
          (see .starterpack/config/models.xml dispatch-override section):
          - light complexity → haiku (light tier)
          - standard complexity → sonnet (worker tier)
          - complex complexity → opus (reasoning tier)
        </action>
        <action>Spawn independent sub-tasks as teammates in parallel, each with its own model tier</action>
        <action>Spawn dependent sub-tasks as teammates sequentially after their dependencies complete</action>
        <action>
          Each implementation teammate receives:
          - The sub-task description, files to modify, acceptance criteria
          - The branch to commit to
          - The ticket ID for commit messages
          - The relevant behavior files (loaded from .starterpack/behaviors/ per the requires-behaviors block below)
        </action>
      </actions>

      <status-message>executing IMPLEMENTATION/DISPATCH on {ticket-id} — launching {N} teammates</status-message>
    </phase>

    <phase name="MONITOR" order="3">
      <actor>Orchestrator (Team Lead)</actor>

      <actions>
        <action>Receive messages from teammates as they complete or encounter issues</action>
        <action>Track: success/failure, files modified, commits made</action>
        <action>
          For failed teammates, collect the structured failure report:
          - What was attempted
          - The error encountered
          - Files involved
          - What was committed (if partial work was saved)
        </action>
      </actions>

      <status-message>executing IMPLEMENTATION/MONITOR on {ticket-id} — {N}/{total} complete</status-message>
    </phase>

    <phase name="EVALUATE" order="4">
      <actor>Orchestrator (Team Lead)</actor>

      <on-success>All teammates succeeded → proceed to HUMAN_GATE</on-success>

      <on-failure>
        <action>Review the failure context and classify the failure type</action>
        <action>
          TECHNICAL FAILURE (logic bug, command error, test failure, syntax issue):
          Spawn an Opus (reasoning tier) teammate with the failure context to attempt resolution.
          If the Opus teammate resolves the issue → loop to DISPATCH for remaining work.
          If the Opus teammate also fails → present to human.
        </action>
        <action>
          REQUIREMENTS FAILURE (plan dictated something impossible, unclear spec, wrong direction,
          missing information, architectural decision needed):
          Present the failure to the human for clarification or course correction.
        </action>
      </on-failure>

      <status-message>executing IMPLEMENTATION/EVALUATE on {ticket-id} — {N} failures, escalating</status-message>
    </phase>

    <phase name="HUMAN_GATE" order="5">
      <actor>Orchestrator (Team Lead) presents to the human</actor>

      <presents>
        <item>Summary of what was implemented</item>
        <item>Files modified</item>
        <item>How to verify/test the changes</item>
        <item>Any concerns raised during implementation</item>
      </presents>

      <gate>BLOCKED — Do not proceed. Human approval required before continuing.</gate>
      <on-rejection>Orchestrator passes feedback to teammates or spawns new teammates → loop to DISPATCH</on-rejection>
      <status-message>awaiting IMPLEMENTATION/HUMAN_GATE on {ticket-id} — BLOCKED: human approval required</status-message>
    </phase>

    <phase name="HANDOFF" order="6">
      <description>
        TRUNK_BASED: proceed to the DOCS workflow.
        FEATURE_BRANCHING: close the child ticket. The beads changes (including the closure)
        are committed on the epic branch and synced to GitHub Issues automatically by the
        CI workflow. The GitHub Issue will be marked "pending-close" until the epic branch
        merges to the default branch. Return to the orchestrator.
        The orchestrator picks the next ready child ticket, or proceeds to DOCS if all children are complete.
      </description>
      <status-message>executing IMPLEMENTATION/HANDOFF on {ticket-id} — transitioning to DOCS</status-message>
    </phase>

  </loop>

  <requires-behaviors>
    <!--
      These behaviors MUST be loaded and included in the instructions given to every
      implementation teammate. The orchestrator (team lead) reads these from .starterpack/behaviors/
      and includes them when spawning teammates.
    -->
    <requires-behavior name="commit-discipline" />
    <requires-behavior name="escalation" section="implementation-agents" />
    <requires-behavior name="scope-enforcement" section="agent-level" />
    <requires-behavior name="sub-task-tracking" />
  </requires-behaviors>

</lifecycle>
