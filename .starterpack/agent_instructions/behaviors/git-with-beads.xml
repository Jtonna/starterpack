<behavior name="git-with-beads">

  <summary>
    All git rules in one place: branching strategies, branch naming, commit format,
    push discipline, and beads integration. Every agent that touches git must follow these rules.
  </summary>

  <!-- ═══════════════════════════════════════════════════════════════════════
       BRANCHING STRATEGIES
       ═══════════════════════════════════════════════════════════════════════ -->

  <section name="branching-strategies">

    <strategy name="TRUNK_BASED">
      For single tickets with small, well-defined scope. One short-lived branch per ticket.
      <when>
        - The ticket is a single feature, bug, task, or chore
        - The scope fits in one planning/implementation cycle
        - No child tickets or decomposition needed
      </when>
      <flow>
        One ticket → one branch (TYPE/ticket-id) → full development cycle
        (plan, implement, document, pull request) → merge → delete branch
      </flow>
    </strategy>

    <strategy name="FEATURE_BRANCHING">
      For epics or large features that decompose into multiple tickets. One long-lived
      feature branch hosts all child ticket work. Child tickets do NOT get their own branches.
      <when>
        - The work originated from a spec file or was identified as an epic during planning
        - Multiple child tickets exist under an epic
      </when>
      <flow>
        Epic ticket → create long-lived branch (EPIC/epic-id) → for each child ticket in dependency order:
          plan and implement on the same branch → close child ticket
        → once all children complete: documentation review (full epic diff against main),
          then pull request → merge → close epic → delete branch
      </flow>
      <rules>
        <rule name="child-commits-to-epic-branch">All child tickets commit to the epic branch, not their own branches</rule>
        <rule name="child-plan-and-implement-only">Each child ticket runs planning and implementation only — no standalone docs review or pull request per child</rule>
        <rule name="docs-review-runs-once">Documentation review runs once after all children are complete, diffing the full epic branch against main</rule>
        <rule name="pr-runs-once">A single pull request is opened at the end for the entire epic, after documentation review</rule>
        <rule name="epic-closed-last">The epic ticket is closed only after all children are closed and the pull request is merged</rule>
      </rules>
    </strategy>

  </section>

  <!-- ═══════════════════════════════════════════════════════════════════════
       STRATEGY SELECTION
       ═══════════════════════════════════════════════════════════════════════ -->

  <section name="strategy-selection">
    <strategy-selection>
      Strategy selection criteria:
      - Spec file → FEATURE_BRANCHING (always)
      - Existing ticket with type "epic" → FEATURE_BRANCHING
      - Existing ticket with any other type → TRUNK_BASED
      - Ad-hoc request → TRUNK_BASED (unless scope grows to require an epic)
    </strategy-selection>
  </section>

  <!-- ═══════════════════════════════════════════════════════════════════════
       BRANCH NAMING
       ═══════════════════════════════════════════════════════════════════════ -->

  <section name="branch-naming">
    <rule name="no-direct-main-commits">Never commit directly to main</rule>
    <rule name="all-commits-on-feature-branch">All commits happen on the feature/epic branch</rule>
    <rule name="branch-created-first">The working branch must be created before any other work begins</rule>

    <issue-type-to-branch>
      <type name="feature" branch-prefix="FEAT/" />
      <type name="bug"     branch-prefix="BUG/" />
      <type name="task"    branch-prefix="TASK/" />
      <type name="chore"   branch-prefix="CHORE/" />
      <type name="epic"    branch-prefix="EPIC/" />
    </issue-type-to-branch>

    <examples>
      <example>git checkout -b FEAT/sp-0004</example>
      <example>git checkout -b BUG/sp-0012</example>
      <example>git checkout -b EPIC/sp-0020</example>
    </examples>
  </section>

  <!-- ═══════════════════════════════════════════════════════════════════════
       COMMIT DISCIPLINE
       ═══════════════════════════════════════════════════════════════════════ -->

  <section name="commit-discipline">
    <rule name="ticket-id-prefix">
      Every commit message starts with the ticket ID being worked (discover prefix from beads, never guess).
      In FEATURE_BRANCHING, use the child ticket ID, not the epic ID.
    </rule>
    <rule name="granular-commits">Commits must be granular — one logical change per commit</rule>
    <rule name="multiple-commits-expected">Multiple commits per sub-task are expected</rule>
    <rule name="atomic-commits">Each commit must be atomic and independently valid (builds, no broken imports)</rule>
    <rule name="no-secrets">Never commit secrets, .env files, or credentials</rule>
    <rule name="include-beads-files">Always include .beads/ files (especially .beads/issues.jsonl) in commits — the pre-commit hook exports the SQLite database to JSONL and stages issues.jsonl automatically, but verify it is included before pushing</rule>
    <rule name="verify-build-before-final-commit">Always verify the build passes before the final commit of a task</rule>
  </section>

  <!-- ═══════════════════════════════════════════════════════════════════════
       PUSH DISCIPLINE
       ═══════════════════════════════════════════════════════════════════════ -->

  <section name="push-discipline">
    <rule name="single-push-authority">
      Only one agent pushes to the remote, and only after human approval.
      This ensures unapproved work never reaches the remote.
    </rule>
    <rule name="push-after-ticket-creation">
      After ticket creation and branch setup: beads metadata (.beads/ files) is committed
      to the new branch and pushed to remote. This is a metadata-only push — no code
      changes are included. It ensures the ticket state is preserved on the remote
      before any further work begins.
    </rule>
    <rule name="push-after-implementation-approval">
      After human approval following implementation: the branch is pushed to remote
      before handing off to the next phase. This is a single push covering all commits.
    </rule>
    <rule name="push-before-pr">
      After human approval before opening the pull request: any remaining commits
      (from documentation updates or ticket closure) are pushed and the pull request is created.
    </rule>
    <rule name="no-force-push">Never force-push unless the human explicitly requests it</rule>
  </section>

</behavior>
